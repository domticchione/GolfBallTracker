import cv2
import numpy as np
import os
import sys

class GolfBallDetector:
    def __init__(self, video_path, template_path, display_mode="original"):
        """Initialize the detector with video and template paths."""
        self.display_mode = "original"  # Options: "original", "grayscale", "edges", "roi"
        self.video_path = "golf_shot.mp4"
        self.template_path = template_path
        self.window_name = f"Golf Ball Detector - {self.display_mode}"
        
        self.contact_detected = False
        self.prev_distance = None  # Add this line
        print("Starting improved shaft and ball detection with contact detection...")

        # Validate file paths
        if not os.path.exists(self.video_path) or not os.path.exists(template_path):
            print("Error: Video or template file not found.")
            sys.exit(1)
        
        # Load video and template
        self.cap = cv2.VideoCapture(self.video_path)
        self.template = cv2.imread(template_path, 0)
        self.template = cv2.resize(self.template, (int(self.template.shape[1] * 1.5), int(self.template.shape[0] * 1.5)))
        self.t_h, self.t_w = self.template.shape
        
        # Video properties
        self.width = int(self.cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        self.height = int(self.cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
        self.fps = int(self.cap.get(cv2.CAP_PROP_FPS))
        print(f"Video: {self.width}x{self.height} at {self.fps}fps")
        
        # Window setup
        cv2.namedWindow(self.window_name, cv2.WINDOW_NORMAL)
        cv2.resizeWindow(self.window_name, self.width // 2, self.height // 2)
        
        # Initialize state variables
        self.frame_count = 0
        self.prev_shaft_position = None
        self.ball_position = None
        self.ball_detected = False
        self.initial_ball_position = None
        self.history = []  # Ball detection history
        self.shaft_history = []  # Last 3 shaft lines for smoothing
        self.avg_history = []  # Last 2 averaged shaft positions for prediction
        self.epsilon = 3  # Adjusted for faster detection
        self.contact_detected = False  # Flag to track contact
        
        print("Starting improved shaft and ball detection with contact detection...")

    def process_frame(self):
        """Process a single frame from the video."""
        ret, frame = self.cap.read()
        if not ret:
            print(f"Stopped at frame {self.frame_count} (end of video)")
            return False

        # Convert to grayscale and HSV
        gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        hsv_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

        # Filter out grass
        filtered_frame = self.filter_grass(hsv_frame, gray_frame)

        # Edge detection
        blurred = cv2.GaussianBlur(filtered_frame, (5,5), 5)
        edges = cv2.Canny(blurred, 50, 200)

        # Define ROI (using full frame as per your adjustment)
        roi = edges

        # Detect shaft
        current_bottom_shaft, display_frame = self.detect_shaft(roi, frame, gray_frame)

        # Detect ball
        self.detect_ball(gray_frame, current_bottom_shaft)

        # Check for contact between shaft and ball
        if current_bottom_shaft and self.ball_position and not self.contact_detected:
            distance = np.sqrt((current_bottom_shaft[0] - self.ball_position[0])**2 + 
                            (current_bottom_shaft[1] - self.ball_position[1])**2)
            contact_threshold = 15  # Tightened from 20 to 10 pixels
            
            # Track previous distance for velocity check
            if hasattr(self, 'prev_distance') and self.prev_distance is not None:
                distance_decreasing = distance < self.prev_distance
            else:
                distance_decreasing = True  # Default for first frame with ball
            
            print(f"Frame {self.frame_count}: Shaft-Ball Distance: {distance:.1f}")

            # Require distance to be small AND decreasing to confirm contact
            if distance < contact_threshold and distance_decreasing:
                print(f"Frame {self.frame_count}: Contact detected! Distance: {distance:.1f}")
                self.contact_detected = True
                cv2.circle(display_frame, self.ball_position, self.t_w * 2, (0, 255, 0), 4)
                self.display_frame(display_frame)
                cv2.waitKey(0)  # Pause indefinitely
                return False
            
            # Store current distance for next frame
            self.prev_distance = distance

        # Display frame
        self.display_frame(display_frame)

        self.frame_count += 1
        if self.frame_count % 50 == 0:
            print(f"Processed {self.frame_count} frames...")
        
        return True

    def detect_shaft(self, roi, frame, gray_frame):
        """Detect the golf shaft in the roi and return its position."""
        # (Your existing detect_shaft method remains unchanged)
        lines = cv2.HoughLinesP(roi, 1, np.pi / 180, threshold=100, minLineLength=100, maxLineGap=8)
        shaft_position = None
        longest_line = None
        max_length = 0
        best_score = float('inf')

        if lines is not None:
            for line in lines:
                x1, y1, x2, y2 = line[0]
                length = np.sqrt((x2 - x1)**2 + (y2 - y1)**2) * 2
                mid_x, mid_y = (x1 + x2) / 2, (y1 + y2) / 2
                candidate_pos = (int(mid_x), int(mid_y))
                score = -length
                if self.prev_shaft_position:
                    dist_prev = np.sqrt((candidate_pos[0] - self.prev_shaft_position[0])**2 + 
                                        (candidate_pos[1] - self.prev_shaft_position[1])**2)
                    score += 0.5 * dist_prev
                if score < best_score:
                    best_score = score
                    max_length = length
                    longest_line = (x1, y1, x2, y2)
                    shaft_position = candidate_pos

        if self.display_mode == "original":
            display_frame = frame.copy()
        elif self.display_mode == "grayscale":
            display_frame = cv2.cvtColor(gray_frame, cv2.COLOR_GRAY2BGR)
        elif self.display_mode == "edges":
            display_frame = cv2.cvtColor(roi, cv2.COLOR_GRAY2BGR)
        elif self.display_mode == "roi":
            display_frame = cv2.cvtColor(roi, cv2.COLOR_GRAY2BGR)

        current_bottom_shaft = None
        if longest_line:
            x1, y1, x2, y2 = longest_line
            current_bottom_shaft = (x2, y2) if y2 > y1 else (x1, y1)
            angle = np.degrees(np.arctan2(y2 - y1, x2 - x1))
            print(f"Frame {self.frame_count}: Shaft at {shaft_position}, length={max_length:.1f}, angle={angle:.1f}Â°, score={best_score:.1f}")
            self.shaft_history.append((x1, y1, x2, y2))
            if len(self.shaft_history) > 3:
                self.shaft_history.pop(0)
            avg_x1 = sum([line[0] for line in self.shaft_history]) / len(self.shaft_history)
            avg_y1 = sum([line[1] for line in self.shaft_history]) / len(self.shaft_history)
            avg_x2 = sum([line[2] for line in self.shaft_history]) / len(self.shaft_history)
            avg_y2 = sum([line[3] for line in self.shaft_history]) / len(self.shaft_history)
            x1_avg, y1_avg, x2_avg, y2_avg = int(avg_x1), int(avg_y1), int(avg_x2), int(avg_y2)
            self.avg_history.append((x1_avg, y1_avg, x2_avg, y2_avg))
            if len(self.avg_history) > 2:
                self.avg_history.pop(0)
            if len(self.avg_history) == 2:
                prev_x1, prev_y1, prev_x2, prev_y2 = self.avg_history[0]
                curr_x1, curr_y1, curr_x2, curr_y2 = self.avg_history[1]
                vel_x1, vel_y1 = curr_x1 - prev_x1, curr_y1 - prev_y1
                vel_x2, vel_y2 = curr_x2 - prev_x2, curr_y2 - prev_y2
                display_x1, display_y1 = int(curr_x1 + vel_x1), int(curr_y1 + vel_y1)
                display_x2, display_y2 = int(curr_x2 + vel_x2), int(curr_y2 + vel_y2)
            else:
                display_x1, display_y1 = x1_avg, y1_avg
                display_x2, display_y2 = x2_avg, y2_avg
            cv2.line(display_frame, (display_x1, display_y1), (display_x2, display_y2), (0, 255, 255), 2)
            display_bottom_shaft = (display_x2, display_y2) if display_y2 > display_y1 else (display_x1, display_y1)
            cv2.circle(display_frame, display_bottom_shaft, 50, (255, 0, 0), 2)
            self.prev_shaft_position = shaft_position

        return current_bottom_shaft, display_frame

    def detect_ball(self, gray_frame, current_bottom_shaft):
        """Detect the golf ball near the shaft position."""
        # (Your existing detect_ball method remains unchanged)
        if current_bottom_shaft and not self.ball_detected:
            roi_size = 200
            roi_x = max(0, current_bottom_shaft[0] - roi_size // 2)
            roi_y = max(0, current_bottom_shaft[1] - roi_size // 2)
            roi_x2 = min(self.width, roi_x + roi_size)
            roi_y2 = min(self.height, roi_y + roi_size)
            ball_roi = gray_frame[roi_y:roi_y2, roi_x:roi_x2]

            if ball_roi.size == 0:
                return

            result = cv2.matchTemplate(ball_roi, self.template, cv2.TM_CCOEFF_NORMED)
            threshold = 0.5
            locations = np.where(result >= threshold)
            ball_candidates = []

            for pt in zip(*locations[::-1]):
                ball_center = (pt[0] + self.t_w // 2 + roi_x, pt[1] + self.t_h // 2 + roi_y)
                dist = np.sqrt((ball_center[0] - current_bottom_shaft[0])**2 + 
                               (ball_center[1] - current_bottom_shaft[1])**2)
                ball_candidates.append((ball_center, dist, result[pt[1], pt[0]]))

            if ball_candidates:
                ball_candidates.sort(key=lambda x: x[1])
                current_ball_position, dist, confidence = ball_candidates[0]
                current_ball_position = (int(current_ball_position[0]), int(current_ball_position[1]))
                print(f"Frame {self.frame_count}: Ball detected at {current_ball_position}, distance to shaft: {dist:.1f}, confidence: {confidence:.2f}")

                if self.history and len(self.history) >= 1:
                    if dist > self.history[-1][1] + self.epsilon:
                        self.ball_detected = True
                        self.initial_ball_position = self.history[-1][0]
                        print(f"Frame {self.frame_count}: Distance increasing, locking ball at {self.initial_ball_position}")
                    else:
                        self.ball_position = current_ball_position
                        self.history.append((self.ball_position, dist))
                        if len(self.history) > 3:
                            self.history.pop(0)
                        print(f"Frame {self.frame_count}: Distance stable or decreasing, updating ball position")
                else:
                    self.ball_position = current_ball_position
                    self.history.append((self.ball_position, dist))
            else:
                self.ball_position = None
                self.history = []

        if self.ball_detected and self.initial_ball_position:
            roi_size = 50
            roi_x = max(0, self.initial_ball_position[0] - roi_size // 2)
            roi_y = max(0, self.initial_ball_position[1] - roi_size // 2)
            roi_x2 = min(self.width, roi_x + roi_size)
            roi_y2 = min(self.height, roi_y + roi_size)
            ball_roi = gray_frame[roi_y:roi_y2, roi_x:roi_x2]

            if ball_roi.size > 0:
                result = cv2.matchTemplate(ball_roi, self.template, cv2.TM_CCOEFF_NORMED)
                max_val = cv2.minMaxLoc(result)[1]
                if max_val < 0.4:
                    self.ball_detected = False
                    self.ball_position = None
                    self.initial_ball_position = None
                    self.history = []
                    print(f"Frame {self.frame_count}: Ball no longer detected, resetting")
                else:
                    self.ball_position = self.initial_ball_position
                    print(f"Frame {self.frame_count}: Ball verified at {self.ball_position}, confidence: {max_val:.2f}")

    def filter_grass(self, hsv_frame, gray_frame):
        """Filter out grass while preserving sunset colors and reducing sky noise."""
        # (Your existing filter_grass method remains unchanged)
        lower_green = np.array([25, 20, 20])
        upper_green = np.array([120, 255, 255])
        grass_mask = cv2.inRange(hsv_frame, lower_green, upper_green)
        sky_height = int(self.height * 0.3)
        sky_region = hsv_frame[:sky_height, :]
        gray_sky = gray_frame[:sky_height, :]
        sobelx = cv2.Sobel(gray_sky, cv2.CV_64F, 1, 0, ksize=5)
        sobely = cv2.Sobel(gray_sky, cv2.CV_64F, 0, 1, ksize=5)
        gradient_mag = np.sqrt(sobelx**2 + sobely**2)
        sky_mask = cv2.threshold(gradient_mag, 20, 255, cv2.THRESH_BINARY_INV)[1].astype(np.uint8)
        full_sky_mask = np.zeros_like(gray_frame, dtype=np.uint8)
        full_sky_mask[:sky_height, :] = sky_mask
        grass_mask = cv2.bitwise_and(grass_mask, cv2.bitwise_not(full_sky_mask))
        blurred_gray = cv2.GaussianBlur(gray_frame, (5, 5), 0)
        variance = cv2.absdiff(gray_frame, blurred_gray)
        texture_mask = cv2.threshold(variance, 15, 255, cv2.THRESH_BINARY)[1].astype(np.uint8)
        grass_mask = cv2.bitwise_and(grass_mask, texture_mask)
        horizon_start = int(self.height * 0.4)
        horizon_end = int(self.height * 0.6)
        horizon_mask = np.ones_like(gray_frame, dtype=np.uint8) * 255
        horizon_mask[horizon_start:horizon_end, :] = 0
        grass_mask = cv2.bitwise_and(grass_mask, horizon_mask)
        kernel = np.ones((3, 3), np.uint8)
        grass_mask = cv2.morphologyEx(grass_mask, cv2.MORPH_OPEN, kernel)
        grass_mask = cv2.morphologyEx(grass_mask, cv2.MORPH_CLOSE, kernel)
        non_grass_mask = cv2.bitwise_not(grass_mask)
        filtered_frame = cv2.bitwise_and(gray_frame, gray_frame, mask=non_grass_mask)
        return filtered_frame

    def display_frame(self, display_frame):
        """Display the frame with overlays."""
        if self.ball_position:
            ball_pos_int = (int(self.ball_position[0]), int(self.ball_position[1]))
            cv2.circle(display_frame, ball_pos_int, self.t_w * 2, (0, 0, 255), 2)

        cv2.imshow(self.window_name, display_frame)
        key = cv2.waitKey(30)
        if key & 0xFF == ord("q"):
            self.cleanup()
            sys.exit(0)

    def run(self):
        """Main loop to process video frames."""
        while self.cap.isOpened():
            if not self.process_frame():
                break
        self.cleanup()

    def cleanup(self):
        """Release resources and close windows."""
        self.cap.release()
        cv2.destroyAllWindows()
        print("Program ended.")

if __name__ == "__main__":
    detector = GolfBallDetector("golf_shot.mp4", "golf_ball_template.png", display_mode="original")
    detector.run()